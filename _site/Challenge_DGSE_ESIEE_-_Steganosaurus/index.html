<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="TonyBounty Blog" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="TonyBounty Blog" /> <title> Challenge DGSE/ESIEE - Steganosaurus - TonyBounty Blog </title> <link rel="alternate" href="https://tonybounty.github.io/Challenge_DGSE_ESIEE_-_Steganosaurus/" hreflang="en-US" /> <link rel="canonical" href="https://tonybounty.github.io/Challenge_DGSE_ESIEE_-_Steganosaurus/" /> <meta name="description" content="" /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="Challenge DGSE/ESIEE - Steganosaurus | " /> <meta property="og:title" content="Challenge DGSE/ESIEE - Steganosaurus | " /> <meta property="og:type" content="website" /> <meta property="og:url" content="https://tonybounty.github.io/Challenge_DGSE_ESIEE_-_Steganosaurus/" /> <meta property="og:description" content="" /> <meta property="og:image" content="https://tonybounty.github.io/Challenge_DGSE_ESIEE_Steganosaurus/first.png" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="Challenge DGSE/ESIEE - Steganosaurus | tony_bounty" /> <meta name="twitter:url" content="https://tonybounty.github.io/Challenge_DGSE_ESIEE_-_Steganosaurus/" /> <meta name="twitter:site" content="@tony_bounty" /> <meta name="twitter:creator" content="@tony_bounty" /> <meta name="twitter:description" content="" /> <meta name="twitter:image" content="https://tonybounty.github.io/Challenge_DGSE_ESIEE_Steganosaurus/first.png" /> <link type="application/atom+xml" rel="alternate" href="https://tonybounty.github.io/feed.xml" title="TonyBounty Blog" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="dark" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">home</a><a class="menu-link" href="/archive/">archive</a><a class="menu-link" href="https://github.com/tonybounty" target="_blank" rel="noopener" >github</a ><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <div class="tags"> <span itemprop="keywords"> <a class="tag" href="/tags/#writeup">WRITEUP</a>, <a class="tag" href="/tags/#dgseesiee">DGSEESIEE</a>, <a class="tag" href="/tags/#flutter">FLUTTER</a>, <a class="tag" href="/tags/#android">ANDROID</a>, <a class="tag" href="/tags/#steganography">STEGANOGRAPHY</a> </span> </div> <h1 class="header-title" itemprop="headline">Challenge DGSE/ESIEE - Steganosaurus</h1> <div class="post-meta"> <time datetime="2020-11-10T15:59:46+01:00" itemprop="datePublished"> Nov 10, 2020 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">TonyBounty™</span> </span> <time hidden datetime="" itemprop="dateModified"> Nov 10, 2020 </time> <span hidden itemprop="publisher" itemtype="Person">TonyBounty™</span> <span hidden itemprop="image">/Challenge_DGSE_ESIEE_Steganosaurus/first.png</span> <span hidden itemprop="mainEntityOfPage"><blockquote> <p><a href="https://www.youtube.com/watch?v=s0rTz2NY3RQ" target="_blank"><strong>Avertissement : vous allez pénétrer dans les arcanes de la DGSE, il vous saurait gré de lire ce WriteUp avec la compilation du service en fond sonore, cliquez ici ou la</strong></a></p> </blockquote> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <blockquote> <p><a href="https://www.youtube.com/watch?v=s0rTz2NY3RQ" target="_blank"><strong>Avertissement : vous allez pénétrer dans les arcanes de la DGSE, il vous saurait gré de lire ce WriteUp avec la compilation du service en fond sonore, cliquez ici ou la</strong></a></p> </blockquote> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/steganosaurus.jpg" /> <figcaption>© Nobu Tamura</figcaption> </figure> <p>Sacrés agents du <em>Service Action</em> ! Ils nous ont dégoté une clé USB abandonnée dans un camion de livraison. Elle y contient apparemment les plus sombres secrets de notre ennemie juré : <strong>Evil Country</strong>. On nous transmet pour analyse un fichier nommé <code class="language-plaintext highlighter-rouge">message</code>, représentant le <em>filesystem</em> de cette clé.</p> <p>Le challenge est classé dans la catégorie Forensic, commençons par passer un petit coup de commande <code class="language-plaintext highlighter-rouge">file</code>, et un tour de moulinette avec <code class="language-plaintext highlighter-rouge">binwalk</code> :</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>file message
message: DOS/MBR boot sector, code offset 0x58+2, OEM-ID <span class="s2">"mkfs.fat"</span>, Media descriptor 0xf8, sectors/track 32, heads 64, hidden sectors 7256064, sectors 266240 <span class="o">(</span>volumes <span class="o">&gt;</span> 32 MB<span class="o">)</span>, FAT <span class="o">(</span>32 bit<span class="o">)</span>, sectors/FAT 2048, reserved 0x1, serial number 0xccd8d7cd, unlabeled
<span class="nv">$ </span>binwalk <span class="nt">-e</span> message
DECIMAL       HEXADECIMAL     DESCRIPTION                                                                                                                       
<span class="nt">--------------------------------------------------------------------------------</span>                                                                                
2114048       0x204200        PNG image, 1000 x 514, 8-bit/color RGBA, non-interlaced                                                                           
3061760       0x2EB800        Zip archive data, at least v2.0 to extract, compressed size: 318, uncompressed size: 442, name: kotlin/ranges/UIntProgressionItera
tor.kotlin_metadata                                                                                                                                             
3085941       0x2F1675        Zip archive data, at least v2.0 to extract, compressed size: 459, uncompressed size: 725, name: kotlin/collections/HashMap.kotlin_
metadata                                                                                                                                                        
3086472       0x2F1888        Zip archive data, at least v2.0 to extract, compressed size: 255, uncompressed size: 320, name: kotlin/SuspendKt.kotlin_metadata  
3086789       0x2F19C5
<span class="nt">---</span> 3&lt; snip <span class="nt">---</span>
</code></pre></div></div> <p>Effectivement, <code class="language-plaintext highlighter-rouge">file</code> reconnait un système de fichier FAT32, <code class="language-plaintext highlighter-rouge">binwalk</code> quant a lui va passer au peigne fin chaque octet du fichier pour essayer de trouver des en-têtes de format de fichier connus. Ainsi il trouve un fichier PNG d’une résolution de 100x514, des archives Zip etc… L’option <strong>-e</strong> permet d’extraire automatiquement ce qu’il trouve.</p> <p>Gardons les résultats de <code class="language-plaintext highlighter-rouge">binwalk</code> pour plus tard, et essayons de monter le fichier pour accéder à cette <em>partition</em> FAT32 :</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>mount message mnt/
<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> mnt/
total 37327
<span class="nt">-rwxr-xr-x</span> 1 root root      532 Oct 15 17:48 readme
<span class="nt">-rwxr-xr-x</span> 1 root root 38221331 Jul  8 16:02 steganausorus.apk
</code></pre></div></div> <p>Deux fichiers sont présents, dont un possédant l’extension en .apk, qui nous fait penser naturellement au format <em>Android Application Package</em>. l’APK est un paquet au format Zip servant de conteneur pour une application Android. Regardons le <code class="language-plaintext highlighter-rouge">readme</code>, et parce que ça ne mange pas de pain un petit coup de <code class="language-plaintext highlighter-rouge">file</code> sur l’APK pour s’assurer du format :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat readme
Bonjour evilcollegue !
Je te laisse ici une note d'avancement sur mes travaux !
J'ai réussi à implémenter complétement l'algorithme que j'avais présenté au QG au sein d'une application.
Je te joins également discrétement mes premiers résultats avec de vraies données sensibles ! Ils sont bons pour la corbeille mais ça n'est que le début !
Je t'avertis, l'application souffre d'un serieux defaut de performance ! je m'en occuperai plus tard.
contente-toi de valider les résultats.
Merci d'avance

For the worst,

QASKAB

$ file steganosaurus.apk
steganausorus.apk: Zip archive data, at least v2.0 to extract
</code></pre></div></div> <p>D’après le <code class="language-plaintext highlighter-rouge">readme</code> il fleure bon que l’on va devoir analyser un algorithme contenu dans une application. De plus la commande <code class="language-plaintext highlighter-rouge">file</code> reconnait une archive Zip. On est quasiment certain d’être en présence d’une application Android, regardons sans plus attendre son contenu :</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>unzip <span class="nt">-l</span> steganosaurus.apk
Archive:  steganausorus.apk                                                                                                                                     
  Length      Date    Time    Name                                                                                                                              
<span class="nt">---------</span>  <span class="nt">----------</span> <span class="nt">-----</span>   <span class="nt">----</span>                                                                                                                              
     4224  1980-00-00 00:00   AndroidManifest.xml                                                                                                               
     1159  1980-00-00 00:00   META-INF/CERT.RSA                                                                                                                 
    34878  1980-00-00 00:00   META-INF/CERT.SF                                                                                                                  
    34835  1980-00-00 00:00   META-INF/MANIFEST.MF                                                                                                              
        6  1980-00-00 00:00   META-INF/androidx.activity_activity.version                                                                                       
        6  1980-00-00 00:00   META-INF/androidx.arch.core_core-runtime.version                                                                                  
        6  1980-00-00 00:00   META-INF/androidx.core_core.version                                                                                               
        6  1980-00-00 00:00   META-INF/androidx.customview_customview.version                                                                                   
        6  1980-00-00 00:00   META-INF/androidx.fragment_fragment.version                                                                                       
        6  1980-00-00 00:00   META-INF/androidx.lifecycle_lifecycle-livedata-core.version                                                                       
        6  1980-00-00 00:00   META-INF/androidx.lifecycle_lifecycle-livedata.version                                                                            
        6  1980-00-00 00:00   META-INF/androidx.lifecycle_lifecycle-runtime.version                                                                             
        6  1980-00-00 00:00   META-INF/androidx.lifecycle_lifecycle-viewmodel.version  
<span class="nt">---</span> 3&lt; snip <span class="nt">---</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>… c’est manifestement une application Android ! Pour naviguer et décompiler le contenu de ce paquet APK, nous utiliserons l’outil <a href="https://github.com/skylot/jadx">Jadx</a> <em>Dex to Java decompiler</em> :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ jadx-gui steganosaurus.apk
</code></pre></div></div> <p>Une fois dans Jadx avec le fichier <code class="language-plaintext highlighter-rouge">steganosaurus.apk</code> chargé, nous cliquons sur le fichier <code class="language-plaintext highlighter-rouge">Resources/AndroidManifest.xml</code> qui est l’un des plus importants d’une application Android. En effet ce fichier est obligatoire et contient les informations générales au bon fonctionnement de cette dernière. C’est un excellent point de départ pour faire connaissance avec <code class="language-plaintext highlighter-rouge">steganausorus</code>.</p> <p>L’application requière l’accès à 3 ressources :</p> <ul> <li>écriture sur un stockage externe (carte sd…)</li> <li>lecture sur un stockage externe (carte sd…)</li> <li>Accès Internet</li> </ul> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/manifest_permissions.png" alt="" /> <figcaption>Permissions demandées par l'application</figcaption> </figure> <p>La balise <code class="language-plaintext highlighter-rouge">&lt;application&gt;</code> et ses attributs nous renseigne sur l’application elle même, comme son nom qui est <code class="language-plaintext highlighter-rouge">stegapp</code> dans <code class="language-plaintext highlighter-rouge">android:label</code> et surtout son point d’entrée dans le code par <code class="language-plaintext highlighter-rouge">android:name=io.flutter.app.FlutterApplication</code>, précisant qu’elle est la première classe à appeler.</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/android_manifest2.png" alt="" /> <figcaption>Balise &lt;application&gt;</figcaption> </figure> <p>Cette classe n’est d’ailleurs pas écrite par l’auteur de l’application, mais elle correspond au kit de développement <a href="http://flutter.dev">Flutter</a>, l’analyser serait une perte de temps.</p> <blockquote> <p>Flutter a été créé par Google et met à disposition tout un tas de classes pour développer des interfaces graphiques mutliplateforme sur la base d’un seul langage le <a href="http://dart.dev">Dart</a>. Le Dart quant à lui est un langage de programmation orienté objet se rapprochant syntaxiquement du C, il génère principalement du code natif.</p> </blockquote> <p>Le code écrit par l’un des membres d’<strong>Evil Country</strong> se situe surement dans l’application <em>Flutter/Dart</em> elle même. Il va nous falloir trouver un moyen le récupérer et de la décompiler, car malheureusement Jadx comprend que le format .dex <em>Dalvik Executable Format</em>.</p> <p>Heureusement, nous avons une des plus impressionnante compétence d’un cétéfeur (un gars qui fait des CTF), celle de pouvoir diagonaliser l’intégralité d’une doc d’un gros SDK en un temps record et le don sacré dans la composition de bons mots-clés pour <em>sniper</em> la ressource nécessaire, c’est à dire celle-ci : <a href="https://medium.com/@rondalal54/reverse-engineering-flutter-apps-5d620bb105c0">Reverse Engineering Flutter Apps</a> :</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/flutter_blog.png" alt="" /> <figcaption></figcaption> </figure> <ul> <li>“Pardon Monsieur? Si l’application est restée en mode debug on peut récupérer le code source avec en bonus les commentaires dans le fichier <code class="language-plaintext highlighter-rouge">kernel_blob.bin</code> de l’apk ?”</li> <li>“Oui Madame!”</li> <li>“Pôpôpôôôô!”</li> </ul> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/kernel_blog_jadx.png" alt="" /> <figcaption></figcaption> </figure> <p><em>Target</em> localisée ! Pour extraire le fichier il suffit d’ouvrir le paquet APK dans 7Zip par exemple, ou tout simplement de le dézipper. Le contenu est censé être du bytecode + peut-être le code en clair, voyons ce que nous trouve la commande <code class="language-plaintext highlighter-rouge">strings</code> :</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">strings</span> <span class="o">-</span><span class="m">10</span> <span class="n">kernel_blob</span><span class="o">.</span><span class="n">bin</span>
<span class="o">---</span> <span class="m">3</span><span class="o">&lt;</span> <span class="n">snip</span> <span class="o">---</span>
<span class="o">&lt;</span><span class="n">org</span><span class="o">-</span><span class="n">dartlang</span><span class="o">-</span><span class="n">sdk</span><span class="o">:</span><span class="c">///third_party/dart/sdk/lib/_http/http.dart</span>
<span class="err">'</span>       <span class="c">// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file</span>
<span class="c">// for details. All rights reserved. Use of this source code is governed by a</span>
<span class="c">// BSD-style license that can be found in the LICENSE file.</span>
<span class="c">// @dart = 2.6</span>
<span class="n">library</span> <span class="n">dart</span><span class="o">.</span><span class="n">_http</span><span class="p">;</span>
<span class="k">import</span> <span class="err">'</span><span class="n">dart</span><span class="o">:</span><span class="n">async</span><span class="err">'</span><span class="p">;</span>
<span class="k">import</span> <span class="err">'</span><span class="n">dart</span><span class="o">:</span><span class="n">collection</span><span class="err">'</span>
        <span class="n">HashMap</span><span class="p">,</span>
        <span class="n">HashSet</span><span class="p">,</span>
        <span class="n">Queue</span><span class="p">,</span>
        <span class="n">ListQueue</span><span class="p">,</span>
        <span class="n">LinkedList</span><span class="p">,</span>
        <span class="n">LinkedListEntry</span><span class="p">,</span>
        <span class="n">UnmodifiableMapView</span><span class="p">;</span>
<span class="k">import</span> <span class="err">'</span><span class="n">dart</span><span class="o">:</span><span class="n">convert</span><span class="err">'</span><span class="p">;</span>
<span class="o">---</span> <span class="m">3</span><span class="o">&lt;</span> <span class="n">snip</span> <span class="o">---</span>
</code></pre></div></div> <p>Well Done <strong>Evil Country</strong>! Qu’est ce c’est beau et tellement rare d’avoir un code lisible et indenté depuis la sortie de la commande <code class="language-plaintext highlighter-rouge">strings</code>, un moment rare, restons quelques minutes à contempler…</p> <p>Comme nous sommes des pros de la DGSE, on va extraire proprement le code lisible du byte code, pour avoir une belle base de travail. En regardant un peu le code on s’aperçoit qu’il contient un paquet de lignes, et qu’elles correspondent au code du SDK Flutter. Il nous faut trouver et isoler le code du fameux <em>QASKAB</em>. Il doit bien y avoir un point d’entrée matérialisé par une fonction ou un truc du genre… Concentration… Diagonalisation… Following the white rabbit… Et Bim <a href="https://dart.dev/guides/language/language-tour#the-main-function">ici</a>. Oui un pauvre <code class="language-plaintext highlighter-rouge">main()</code>, manque total d’originalité de la part du Dart.</p> <p>On tapote frénétiquement sur <code class="language-plaintext highlighter-rouge">n</code> dans <code class="language-plaintext highlighter-rouge">Vim</code> avec le pattern mal choisi <code class="language-plaintext highlighter-rouge">main()</code>. Il nous faut tomber sur le bon. Pour cela on remarque en amont de chaque <code class="language-plaintext highlighter-rouge">main()</code> une en-tête de début de fichier Dart, avec le chemin vers celui-ci émanant de la machine du développeur. Il devient facile de faire le <em>distinguo</em> entre un <code class="language-plaintext highlighter-rouge">main()</code> perdu de la bibliothèque Flutter et celui-là par exemple :</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/code_main.png" alt="" /> <figcaption></figcaption> </figure> <p>Extrayons ce fichier. Pour cela nous utilisons ici une recette ultra sophistiquée :</p> <ul> <li><code class="language-plaintext highlighter-rouge">vim kernel_blog.bin</code></li> <li><code class="language-plaintext highlighter-rouge">530089GV530380Gy</code> <em>(on respecte la casse hein)</em></li> <li><code class="language-plaintext highlighter-rouge">:e le_code.dart</code></li> <li><code class="language-plaintext highlighter-rouge">p:wq</code></li> </ul> <blockquote> <p>C’est une <a href="https://www.vimgolf.com/">recette</a> de chef, comprendra qui pourra. Sinon on peut le faire à la souris, mais ça va mal passer à la <em>Piscine</em> car c’est les ptis gars du <a href="https://fr.wikipedia.org/wiki/Government_Communications_Headquarters">GCHQ</a> qui font ça.</p> </blockquote> <p>On a beau être en couple avec <code class="language-plaintext highlighter-rouge">Vim</code> depuis longtemps, mais quand il s’agit d’analyser et surtout de naviguer efficacement dans du code inconnu, rien ne vaut la souris (<em>“tu viens pas de dire que c’est au GCHQ qu’on fait ça?” “non mais ça c’était dans l’autre paragraphe”</em>), pour cela voici plusieurs armes suivant les caractéristiques du soldat :</p> <ul> <li><code class="language-plaintext highlighter-rouge">VsCode</code> si t’as pas de barbe</li> <li><code class="language-plaintext highlighter-rouge">VsCodium</code> barbe naissante</li> <li><code class="language-plaintext highlighter-rouge">Emacs</code> barbe de classe <a href="https://en.wikipedia.org/wiki/Richard_Stallman">Stallman</a></li> </ul> <blockquote> <p>ces 3 éditeurs de code / IDE ont pour point commun d’avoir une extension Vim, (voir même <a href="https://www.emacswiki.org/emacs/Evil">Evil</a>… Country?!) ouf l’honneur du Service est sauf.</p> </blockquote> <p>N’oubliez pas d’installer les extensions qui vont bien : Flutter et Dart. Ouvrez votre code, et la c’est noël à Disney Land, de la couleur partout :</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/vscode.png" alt="" /> <figcaption></figcaption> </figure> <p>L’intérêt de VsCode ici, c’est qu’il va nous permettre d’avoir rapidement la doc juste en passant la souris sur les classes de bibliothèque, et de faire ressortir les variables dans tout le code quand on place le curseur sur l’une d’elle (matérialisé par un encadré de couleur rose…)</p> <p>Bien que le langage Dart nous est inconnu au Service, il est assez facile à comprendre. De toutes les manières on a pas le temps d’apprendre a coder en Dart, en plus si vous avez vu la série <em>Le Bureau Des Légendes</em>, vous êtes au courant que l’on est à peine deux au <em>service informatique</em>, il y a <a href="https://www.leparisien.fr/resizer/ru0O3UwrS_7vlpGd6T29I1kDoxc=/932x582/cloudfront-eu-central-1.images.arcpublishing.com/leparisien/32V524TJKF3ZIK3RLZSJJJCSAY.jpg">lui</a> et moi.</p> <p>Visiblement cette application bidouille une image en entrée pour en ressortir une autre. Avant d’aller plus loin, allons voir a quoi ressemble cette APK en l’exécutant sur notre <a href="https://fr.wikipedia.org/wiki/Teorem">téléphone</a> de service… Ah bah non… on ne peut toujours pas installer d’application (ni même Candy Crush…) cette mise à jour n’arrivera donc jamais ! Rabattons nous sur un <a href="https://developer.android.com/studio">émulateur</a>.</p> <p>Une fois notre téléphone allumé, il nous reste plus qu’a pousser l’application sur ce dernier :</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>adb devices
List of devices attached
emulator-5554   device
<span class="nv">$ </span>adb push steganausorus.apk /sdcard/Download/
steganausorus.apk: 1 file...MB/s <span class="o">(</span>38221331 bytes <span class="k">in </span>0.350s<span class="o">)</span>
</code></pre></div></div> <p>On paramètre le téléphone pour installer des applications non vérifiées, puis on tapote dé-li-ca-te-ment sur <code class="language-plaintext highlighter-rouge">Stegapp</code> :</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/android_emulator.png" alt="" /> <figcaption></figcaption> </figure> <p>Un message secret à cacher dans une image… un nom évocateur… nous sommes très probablement sur une application de stéganographie (quel falair!). On test avec une belle image de Labrador pour voir le résultat… Punaise ça rame ! En effet le machin souffre d’un <strong>serieux</strong> problème de performance (on a été prévenu), ça va être râpé pour l’analyse dynamique…</p> <blockquote> <p>Dans VsCode par exemple il possible (avec les extensions) de créer une nouvelle application Flutter, coller le code que l’on a extrait, puis de faire une analyse dynamique en mode live debug.</p> </blockquote> <p>Maintenant que l’on y voit un peu plus clair, il n’y a plus qu’a lire la documentation qui nous est fournie (le code quoi). Un tapotage sur le bouton <em>Start Hide &amp; seek game</em> fait quelques vérifications et appelle la fonction <code class="language-plaintext highlighter-rouge">steggapp</code> avec pour paramètres le chemin vers l’image <code class="language-plaintext highlighter-rouge">_image</code>, et le texte à dissimuler <code class="language-plaintext highlighter-rouge">myController.text</code>:</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/start_steggapp.png" alt="" /> <figcaption>dans la fonction Build()</figcaption> </figure> <p>Chaque caractère du message à dissimuler va être transformé en binaire sous forme d’une chaîne de caractère ASCII de type <code class="language-plaintext highlighter-rouge">String</code> à l’aide de la fonction <code class="language-plaintext highlighter-rouge">MessageToBinaryString()</code> (si c’est pas explicite ça). Un caractère occupera systématiquement 8 bits, si il fait moins on le <em>GaucheCapitonne(padLeft)</em> avec des 0. Par exemple, <code class="language-plaintext highlighter-rouge">BOB</code> donnera <code class="language-plaintext highlighter-rouge">01000010 01001111 01000010</code> (sans espace) :</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">String</span> <span class="nf">MessageToBinaryString</span><span class="p">(</span><span class="kt">String</span> <span class="n">pMessage</span><span class="o">){</span>
    <span class="kt">String</span> <span class="n">Result</span><span class="o">;</span>
    <span class="n">Result</span><span class="o">=</span><span class="s">""</span><span class="o">;</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">utf8</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">pMessage</span><span class="o">);</span>
    <span class="n">bytes</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">item</span><span class="o">)</span> <span class="o">{</span> <span class="n">Result</span><span class="o">+=</span><span class="n">item</span><span class="o">.</span><span class="na">toRadixString</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">padLeft</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span><span class="s">'0'</span><span class="o">);});</span>
    <span class="k">return</span> <span class="n">Result</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div></div> <p>Le résultat de la fonction est stocké dans <code class="language-plaintext highlighter-rouge">binaryStringmessage</code> :</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">binaryStringmessage</span> <span class="o">=</span> <span class="n">MessageToBinaryString</span><span class="o">(</span><span class="n">pMessage</span><span class="o">);</span>
</code></pre></div></div> <p>L’image est ensuite lue et convertie au format RGBA puis redimensionnée de sorte que l’image ai une largeur de 1000 pixels. Cette première constante est très importante, car l’image finale embarquant le message fera systématiquement 1000 pixels de large. C’est un indicateur fort. D’autre part, ces 1000px ne nous rappelle pas quelque chose? Il disait quoi déjà le <code class="language-plaintext highlighter-rouge">binwalk</code> du début ?</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span><span class="o">.</span><span class="na">Image</span> <span class="n">aimage</span> <span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="na">Image</span><span class="o">.</span><span class="na">fromBytes</span><span class="o">(</span><span class="n">decodedImage</span><span class="o">.</span><span class="na">width</span><span class="o">,</span><span class="n">decodedImage</span><span class="o">.</span><span class="na">height</span><span class="o">,</span> <span class="n">imgintlist</span><span class="o">,</span> <span class="nl">format:</span> <span class="n">A</span><span class="o">.</span><span class="na">Format</span><span class="o">.</span><span class="na">rgba</span><span class="o">);</span>
<span class="n">A</span><span class="o">.</span><span class="na">Image</span> <span class="n">resisedimage</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="na">copyResize</span><span class="o">(</span><span class="n">aimage</span><span class="o">,</span><span class="nl">width:</span><span class="mi">1000</span><span class="o">);</span>
</code></pre></div></div> <p>Un petit rappel sur le format RGBA32 (ou en français RVBA pour Rouge Vert Bleu Alpha) ne va pas faire de mal pour comprendre ce qui va suivre. Un pixel de notre image est un savant mélange d’intensité de rouge, de vert et de bleu (rappelez vous les trucs moches que vous faisiez en Art Plastique). On parle de canal pour chaque couleur, du coup nous avons 3 canaux Rouge Vert Bleu, plus 1 autre appelé Alpha qui se rapporte à l’intensité de transparence de l’image. Comme nous sommes dans un format RGBA<strong>32</strong> pour 32bits(4 octets ), il faut qu’un unique pixel tienne dans…. 32 bits ! On a 4 canaux à faire entrer là-dedans, et pour éviter les disputes on fait un partage équitable, 32bits/4 canaux = 8 bits. Bon voilà, chacun pourra prendre une valeur codée sur 8 bits, c’est à dire de 0 à 255 en notation décimale.</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/rgba.png" alt="" /> <figcaption></figcaption> </figure> <p>Il faut aussi respecter l’ordre de lecture du format RGBA32 :</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/rgbabits.png" alt="" /> </figure> <p>Revenons à notre image redimensionnée stockée dans <code class="language-plaintext highlighter-rouge">resisedimage</code>, l’application va parcourir cette image - donc un tableau de 32bits (= 1 pixel) - puis transformer cette valeur en binaire sous forme d’une chaîne de caractère. Un petit problème se pose pendant la conversion en binaire avec <code class="language-plaintext highlighter-rouge">toRadixString</code>, en effet l’ordre des canaux vont être inversés, on se retrouve avec du ABGR. On ne rentrera pas dans les détails, c’est une sombre histoire de <a href="https://fr.wikipedia.org/wiki/Boutisme">Boutisme</a> (pas la religion hein). Pour contrer ce problème on remet dans l’ordre les canaux puis on concatène tous les pixels dans une MEGA chaîne de caractère <code class="language-plaintext highlighter-rouge">MegaString</code>. Remarque importante, avec le premier <code class="language-plaintext highlighter-rouge">substring(8)</code> on ignore complètement le canal Alpha.</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MegaString</span><span class="o">=</span><span class="s">""</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">resisedimage</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
  <span class="n">RRGGBBString</span><span class="o">=</span><span class="n">resisedimage</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toRadixString</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">padLeft</span><span class="o">(</span><span class="mi">32</span><span class="o">,</span> <span class="s">'0'</span><span class="o">).</span><span class="na">substring</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span> <span class="c1">// ByeBye l'Alpha</span>
  <span class="n">PixelString</span><span class="o">=</span><span class="n">RRGGBBString</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">16</span><span class="o">,</span><span class="mi">24</span><span class="o">)+</span> <span class="c1">// Rouge</span>
              <span class="n">RRGGBBString</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span><span class="mi">16</span><span class="o">)+</span>  <span class="c1">// Vert</span>
              <span class="n">RRGGBBString</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">8</span><span class="o">);</span>   <span class="c1">// Bleu</span>
  <span class="n">MegaString</span><span class="o">+=</span><span class="n">PixelString</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>Les choses sérieuses commencent, une boucle <code class="language-plaintext highlighter-rouge">while</code> va mouliner tant que l’on a pas traiter tous les chiffres binaires de la chaîne <code class="language-plaintext highlighter-rouge">binaryStringmessage</code> :</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="o">(</span><span class="n">messaggelength</span> <span class="o">&lt;</span> <span class="n">binaryStringmessage</span><span class="o">.</span><span class="na">length</span> <span class="o">)</span> <span class="o">{</span>
</code></pre></div></div> <p>Juste avant cette boucle une nouvelle variable <code class="language-plaintext highlighter-rouge">Megastringtosearch</code> est initialisée avec pour valeur le contenu de <code class="language-plaintext highlighter-rouge">MegaString</code> tronqué de ses N premiers bits. Où N = taille de MegaString / 4:</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">String</span> <span class="n">Megastringtosearch</span><span class="o">=</span> <span class="n">MegaString</span><span class="o">.</span><span class="na">substring</span><span class="o">((</span><span class="n">MegaString</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">4</span><span class="o">).</span><span class="na">round</span><span class="o">());</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Megastringtosearch</code> va être notre dictionnaire pour coder notre message (<code class="language-plaintext highlighter-rouge">binaryStringmessage</code>). Dans le <code class="language-plaintext highlighter-rouge">while</code> précédent, une nouvelle boucle est créée. C’est une boucle de recherche. Elle va essayé de déterminer la plus grande suite de bits possibles d’un seul bloc correspondant à notre message secret. La recherche se fait dans <code class="language-plaintext highlighter-rouge">Megastringtosearch</code>. On note la position <code class="language-plaintext highlighter-rouge">offset</code> et la longueur <code class="language-plaintext highlighter-rouge">lengthtostore</code> de notre trouvaille :</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// offsettostore != -1, tant que indexOf trouve une suite</span>
<span class="c1">// substringtoFind.length&lt;=messagetohide.length-1, tant qu'on ne dépasse pas notre message</span>
<span class="k">while</span><span class="o">(</span><span class="n">offsettostore</span> <span class="o">!=-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">substringtoFind</span><span class="o">.</span><span class="na">length</span><span class="o">&lt;=</span><span class="n">messagetohide</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
  <span class="n">lengthtostore</span> <span class="o">=</span> <span class="n">substringtoFind</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// on stocke la taille depuis la pos dans Megastringtosearch</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="n">offsettostore</span><span class="o">;</span> <span class="c1">// on stocke la position dans Megastringtosearch</span>
  <span class="c1">// tant qu'on trouve on ajoute un nouveau bit à la recherche</span>
  <span class="n">substringtoFind</span> <span class="o">=</span> <span class="n">messagetohide</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">substringtoFind</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="c1">// notre chaîne de bits est trouvable dans Megastrintosearch, sinon indexOf retourne -A</span>
  <span class="n">offsettostore</span> <span class="o">=</span> <span class="n">Megastringtosearch</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">substringtoFind</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>Toujours dans notre première boucle, un test est réalisé pour évaluer si l’on a trouvé l’intégralité de notre message dans les données de l’image. Si c’est le cas on stoppe la première boucle, sinon on continue à chercher un nouveau morceau restant de notre message sous forme de bits. Pour chaque bloc trouvé, on stocke la paire de valeurs [<code class="language-plaintext highlighter-rouge">offset</code>, <code class="language-plaintext highlighter-rouge">lenghtostore</code>] dans le tableau <code class="language-plaintext highlighter-rouge">offsetarray</code>:</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Tout trouvé ?</span>
<span class="k">if</span><span class="o">(</span><span class="n">substringtoFind</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">messagetohide</span><span class="o">.</span><span class="na">length</span>  <span class="o">){</span>
  <span class="kt">int</span> <span class="n">lastoffsettostore</span><span class="o">=</span><span class="n">Megastringtosearch</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">substringtoFind</span><span class="o">);</span>
  <span class="c1">// ça dépasse un peu?</span>
  <span class="k">if</span><span class="o">(</span><span class="n">lastoffsettostore</span><span class="o">==-</span><span class="mi">1</span><span class="o">){</span>
    <span class="c1">// on stocke les résultats dans offsetarray + le bit qui dépasse</span>
    <span class="n">offsetarray</span><span class="o">.</span><span class="na">add</span><span class="o">([</span><span class="n">offset</span><span class="o">,</span> <span class="n">lengthtostore</span><span class="o">]);</span> 
    <span class="n">offsetarray</span><span class="o">.</span><span class="na">add</span><span class="o">([</span><span class="n">Megastringtosearch</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">substringtoFind</span><span class="o">[-</span><span class="mi">1</span><span class="o">]),</span><span class="mi">1</span><span class="o">]);</span>
  <span class="o">}</span>
  <span class="c1">// ça dépasse pas:</span>
  <span class="k">else</span><span class="o">{</span>
    <span class="n">offsetarray</span><span class="o">.</span><span class="na">add</span><span class="o">([</span><span class="n">Megastringtosearch</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">substringtoFind</span><span class="o">),</span><span class="n">substringtoFind</span><span class="o">.</span><span class="na">length</span><span class="o">]);</span>
    <span class="kd">var</span> <span class="n">lastitem</span><span class="o">=</span><span class="n">offsetarray</span><span class="o">.</span><span class="na">last</span><span class="o">;</span>      <span class="o">}</span>
  <span class="c1">//</span>
  <span class="n">messaggelength</span><span class="o">+=</span><span class="n">substringtoFind</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// on a trouvé qu'un bloc</span>
<span class="k">else</span> <span class="o">{</span>
  <span class="c1">// on retire le bloc trouvé</span>
  <span class="n">messagetohide</span> <span class="o">=</span> <span class="n">messagetohide</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">substringtoFind</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">messaggelength</span> <span class="o">+=</span> <span class="n">substringtoFind</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="c1">// on stocke le résultat</span>
  <span class="n">offsetarray</span><span class="o">.</span><span class="na">add</span><span class="o">([</span><span class="n">offset</span><span class="o">,</span> <span class="n">lengthtostore</span><span class="o">]);</span>
  <span class="n">offsettostore</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">lengthtostore</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="c1">// on recommence à trouver un nouveau bloc</span>
  <span class="n">substringtoFind</span> <span class="o">=</span> <span class="n">messagetohide</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p>Bon on récapitule un peu, on a dans l’ordre :</p> <ul> <li>notre message secret est transformé en binaire sous forme ASCII <code class="language-plaintext highlighter-rouge">101010100...</code></li> <li>on fait de même avec les pixels de l’image <code class="language-plaintext highlighter-rouge">10101011...</code></li> <li>on fait une table de recherche avec les données de cette image moins les 25% du début</li> <li>on essaye de trouver une suite identique dans notre message et dans la table</li> <li>on stocke la position de cette suite sous forme [position,longueur] dans <code class="language-plaintext highlighter-rouge">offsetarray</code></li> <li>on fait cette recherche pour l’intégralité de notre message</li> </ul> <p><code class="language-plaintext highlighter-rouge">offsetarray</code> devient le précieux résultat permettant de retrouver le message secret à l’aide de la position|longueur. Il faut donc pouvoir stocker ce tableau dans l’image. C’est justement l’étape qui suit.</p> <p>Pour cela une nouvelle variable de type <code class="language-plaintext highlighter-rouge">String</code> fait son apparition : <code class="language-plaintext highlighter-rouge">stringtowrite</code>. Comme son nom l’indique (merci <strong>Evil Country</strong>) elle va contenir notre tableau d’offset qui sera écrit au tout début de l’image. Voilà à quoi va ressembler ce début d’image :</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/header.png" alt="" /> <figcaption></figcaption> </figure> <p>et son code :</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">offsetdatasize</span> <span class="o">=</span> <span class="n">resisedimage</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">lenghtdatasize</span> <span class="o">=</span> <span class="n">binaryStringmessage</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">lenghtsizebit</span> <span class="o">=</span> <span class="n">lenghtdatasize</span><span class="o">.</span><span class="na">toRadixString</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">datasizebit</span> <span class="o">=</span> <span class="n">offsetdatasize</span><span class="o">.</span><span class="na">toRadixString</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">length</span><span class="o">;</span>
<span class="kt">String</span> <span class="n">stringtowrite</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
<span class="c1">// taille de offsetarray + lenghtdatasize</span>
<span class="n">stringtowrite</span> <span class="o">+=</span> <span class="n">offsetarray</span><span class="o">.</span><span class="na">length</span><span class="o">.</span><span class="na">toRadixString</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">padLeft</span><span class="o">(</span><span class="n">datasizebit</span><span class="o">,</span> <span class="s">'0'</span><span class="o">)</span> <span class="o">+</span>
                  <span class="n">lenghtsizebit</span><span class="o">.</span><span class="na">toRadixString</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">padLeft</span><span class="o">(</span><span class="n">datasizebit</span><span class="o">,</span> <span class="s">'0'</span><span class="o">);</span>

<span class="c1">// on ajoute toutes les paires [offset,longueur] </span>
<span class="n">offsetarray</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">listofdata</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">stringtowrite</span> <span class="o">+=</span> <span class="n">listofdata</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">toRadixString</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">padLeft</span><span class="o">(</span><span class="n">datasizebit</span><span class="o">,</span> <span class="s">'0'</span><span class="o">)</span> <span class="o">+</span>
                    <span class="n">listofdata</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">toRadixString</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">padLeft</span><span class="o">(</span><span class="n">lenghtsizebit</span><span class="o">,</span> <span class="s">'0'</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">dataSizeBit</code> correspond au nombre de bits contenus dans la valeur calculée <code class="language-plaintext highlighter-rouge">resised.length * 8 * 3</code>. Comme son nom l’indique, elle va nous renseigner sur la taille d’une donnée de l’en-tête, ou d’un bloc du schéma précédent si l’on préfère. A chaque fois que l’on voudra extraire un message secret d’<strong>Evil Country</strong> il nous faudra faire le calcul ci-dessus pour déterminer comment lire l’en-tête. Note importante, dans le code Dart <code class="language-plaintext highlighter-rouge">length</code> retourne le nombre de pixels (RGBA), la taille n’est donc pas en octet, mais un multiple de 4 octets. Pour avoir la taille en octet il suffit de diviser par 4 : <code class="language-plaintext highlighter-rouge">Length/4</code>.</p> <ul> <li>Le premier bloc de notre en-tête contient le nombre de paires [offset,longueur] à lire.</li> <li>Le deuxième bloc contient la variable <code class="language-plaintext highlighter-rouge">lengthsizebite</code> déterminée en comptant le nombre de bits contenus dans le message secret. Elle indique la dimension d’un bloc <em>longueur</em> qui eux n’ont pas la taille <code class="language-plaintext highlighter-rouge">dataSizeBit</code>.</li> <li>le reste des blocs correspondent aux paires à lire suivant le nombre récupéré dans le premier point.</li> </ul> <p>Voilà ! Avec ces informations on peut déjà coder notre propre décodeur ! Mais… encore faut-il avoir une image à décoder !? Une image qui d’après notre analyse fait 1000 pixels de largeur, et qui en plus devrait avoir des pixels étranges en son début…</p> <p>Vous vous souvenez du petit coup de <code class="language-plaintext highlighter-rouge">binwalk</code> en début de page ? Il nous avait pas trouvé justement un PNG de 1000 x 514, 8-bits/color RGBA ? Alors ? Bon bah je vais vous le dire alors, oui on a un PNG planqué qui a du être normalement extrait si vous avez bien utilisé l’option -e de <code class="language-plaintext highlighter-rouge">binwalk</code>. Allons voir ça de plus près :</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">file</span> <span class="n">_message</span><span class="o">.</span><span class="na">extracted</span><span class="o">/</span><span class="mi">204200</span> 
<span class="n">message</span><span class="o">.</span><span class="na">extracted</span><span class="o">/</span><span class="mi">204200</span><span class="o">:</span> <span class="n">PNG</span> <span class="n">image</span> <span class="n">data</span><span class="o">,</span> <span class="mi">1000</span> <span class="n">x</span> <span class="mi">514</span><span class="o">,</span> <span class="mi">8</span><span class="o">-</span><span class="n">bit</span><span class="o">/</span><span class="n">color</span> <span class="n">RGBA</span><span class="o">,</span> <span class="n">non</span><span class="o">-</span><span class="n">interlaced</span>
<span class="err">$</span> <span class="n">eog</span> <span class="n">_message</span><span class="o">.</span><span class="na">extracted</span><span class="o">/</span><span class="mi">204200</span>
</code></pre></div></div> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/thepng.png" alt="" /> <figcaption></figcaption> </figure> <p>Oh la belle image! Les petites barres veulent surement dire quelque chose, comptons les…. <strong>NON</strong>. Tiens… Il y a des pixels étranges dans le coin supérieur gauche :</p> <figure> <img src="/assets/img/Challenge_DGSE_ESIEE_Steganosaurus/strangepixels.png" alt="" /> <figcaption></figcaption> </figure> <p>Cette image a l’air de contenir un grand secret injecté par l’algorithme que l’on a analysé plus haut. Réalisons le décodeur. Pour changer du Python on va le faire en GoLang… En fait pour ne rien vous cacher, on a pas vraiment le choix, les gars du Service Action sont tous des militaires endurcis, il suffit de dire “<a href="https://en.wikipedia.org/wiki/No-go_pill">NoGo</a>” pour les mettre en pétard, du coup on s’est mis au Go, on est plus serein.</p> <p>Commençons par faire une petite fonction qui prend en entrée un fichier et nous retourne une image RGBA :</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">readFileToImgRGBA</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">image</span><span class="o">.</span><span class="n">RGBA</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">srcimg</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">png</span><span class="o">.</span><span class="n">Decode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"readImgInRGBA: %w"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c">// on récupère les paramètres de notre image</span>
	<span class="n">bounds</span> <span class="o">:=</span> <span class="n">srcimg</span><span class="o">.</span><span class="n">Bounds</span><span class="p">()</span>
	<span class="c">// on crée une image vide avec le format RGBA et les paramètres de notre image</span>
	<span class="n">img</span> <span class="o">:=</span> <span class="n">image</span><span class="o">.</span><span class="n">NewRGBA</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
	<span class="c">// on copie notre image, en bref on vient de la convertir en RGBA comme dans l'application</span>
	<span class="n">draw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">srcimg</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">Point</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">},</span> <span class="n">draw</span><span class="o">.</span><span class="n">Src</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">img</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div> <p>Pour ceux qui ne connaissent pas trop le Go, l’opérateur <code class="language-plaintext highlighter-rouge">:=</code> permet de faire de l’inférence de type (il a dit quoi la ?). En gros on se casse pas la tête à choisir un type, on laisse le compilateur choisir, comme avec <code class="language-plaintext highlighter-rouge">auto</code> en C++.</p> <p>On se fait plaisir et on fait une autre petite fonction qui prend en entrée un tableau d’octets. Elle va nous mouliner tout ça pour en sortir une chaîne de caractère binaire. Plutôt utile n’est-ce pas !</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// convertToBitsString convertit chaque octet en chiffre</span>
<span class="c">// binaire sous forme ASCII. Il capitonne de 0 par la gauche</span>
<span class="c">// si le nombre de caractère est inférieur à 8 (bits)</span>
<span class="k">func</span> <span class="n">convertToBitsString</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="o">*</span><span class="kt">string</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">build</span> <span class="n">strings</span><span class="o">.</span><span class="n">Builder</span> <span class="c">// strings.Builder car performant</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">build</span><span class="p">,</span> <span class="s">"%08b"</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c">// on convertit + capitonnage</span>
	<span class="p">}</span>
	<span class="n">strbuild</span> <span class="o">:=</span> <span class="n">build</span><span class="o">.</span><span class="n">String</span><span class="p">()</span> <span class="c">// on transforme en  string</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">strbuild</span>
<span class="p">}</span>
</code></pre></div></div> <p>Vous vous rappelez que l’on n’utilise pas le canal Alpha de l’image pour construire le dictionnaire <code class="language-plaintext highlighter-rouge">Megastringtosearch</code> tronqué depuis <code class="language-plaintext highlighter-rouge">MegaString</code>. Il nous faut une fonction pour filtrer ça: <code class="language-plaintext highlighter-rouge">imgToRGB</code> prend une image en RGBA pour retourner un tableau d’octet en RGB <em>sans A</em>:</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">imgToRGB</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span><span class="n">image</span><span class="o">.</span><span class="n">RGBA</span><span class="p">)</span> <span class="p">(</span><span class="n">res</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Y</span> <span class="o">:=</span> <span class="n">img</span><span class="o">.</span><span class="n">Bounds</span><span class="p">()</span><span class="o">.</span><span class="n">Max</span><span class="o">.</span><span class="n">Y</span>
  <span class="n">X</span> <span class="o">:=</span> <span class="n">img</span><span class="o">.</span><span class="n">Bounds</span><span class="p">()</span><span class="o">.</span><span class="n">Max</span><span class="o">.</span><span class="n">X</span>
  <span class="k">for</span> <span class="n">y</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">Y</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">x</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">{</span>
      <span class="n">r</span> <span class="o">:=</span> <span class="n">img</span><span class="o">.</span><span class="n">RGBAAt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">R</span>
      <span class="n">g</span> <span class="o">:=</span> <span class="n">img</span><span class="o">.</span><span class="n">RGBAAt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">G</span>
      <span class="n">b</span> <span class="o">:=</span> <span class="n">img</span><span class="o">.</span><span class="n">RGBAAt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">B</span>
      <span class="n">res</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div> <p>Et pour finir voici la fonction principale, qui est non optimisée mais qui réutilise les même nom de variable et la même structure que dans le code Dart :</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">decode</span><span class="p">(</span><span class="n">imgRGBA</span> <span class="o">*</span><span class="n">image</span><span class="o">.</span><span class="n">RGBA</span><span class="p">)</span> <span class="p">(</span><span class="n">flag</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// on supprime le canal Alpha, RGBA =&gt; tableau octet format RGB</span>
	<span class="n">imgbytes</span> <span class="o">:=</span> <span class="n">imgToRGB</span><span class="p">(</span><span class="n">imgRGBA</span><span class="p">)</span>
	<span class="c">// on calcul la taille de l'image RGBA en mémoire</span>
	<span class="n">imgOrigSize</span> <span class="o">:=</span> <span class="n">imgRGBA</span><span class="o">.</span><span class="n">Bounds</span><span class="p">()</span><span class="o">.</span><span class="n">Max</span><span class="o">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">imgRGBA</span><span class="o">.</span><span class="n">Bounds</span><span class="p">()</span><span class="o">.</span><span class="n">Max</span><span class="o">.</span><span class="n">Y</span> <span class="o">*</span> <span class="m">4</span>

	<span class="c">// on calcule la taille dataSizeBit</span>
	<span class="n">imgPixelLength</span> <span class="o">:=</span> <span class="n">imgOrigSize</span> <span class="o">/</span> <span class="m">4</span> <span class="c">// ouais c'est pour la lisibilité le /4</span>
	<span class="n">offsetDataSize</span> <span class="o">:=</span> <span class="n">imgPixelLength</span> <span class="o">*</span> <span class="m">8</span> <span class="o">*</span> <span class="m">3</span>
	<span class="n">dataSizeBit</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%b"</span><span class="p">,</span> <span class="n">offsetDataSize</span><span class="p">))</span>

	<span class="c">// on convertit les octets de l'image en binaire ASCII</span>
	<span class="n">megaString</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="n">convertToBitsString</span><span class="p">(</span><span class="n">imgbytes</span><span class="p">))</span>

	<span class="c">// on tronque le début de megaString</span>
	<span class="n">megaStringLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">megaString</span><span class="p">)</span> <span class="o">/</span> <span class="m">4</span>
	<span class="n">megaOffset</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Round</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">megaStringLen</span><span class="p">)))</span>
	<span class="n">megaStringToSearch</span> <span class="o">:=</span> <span class="n">megaString</span><span class="p">[</span><span class="n">megaOffset</span><span class="o">:</span><span class="p">]</span> <span class="c">// notre dictionnaire</span>

	<span class="c">// strconv.ParseUint("10101011", base 2, nombre de bits à lire) = valeur en UINT</span>
	<span class="n">arraySize</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">ParseUint</span><span class="p">(</span><span class="n">megaString</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="n">dataSizeBit</span><span class="p">],</span> <span class="m">2</span><span class="p">,</span> <span class="n">dataSizeBit</span><span class="p">)</span>
	<span class="n">megaString</span> <span class="o">=</span> <span class="n">megaString</span><span class="p">[</span><span class="n">dataSizeBit</span><span class="o">:</span><span class="p">]</span>

	<span class="n">lengthSizeBit64</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">ParseUint</span><span class="p">(</span><span class="n">megaString</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="n">dataSizeBit</span><span class="p">],</span> <span class="m">2</span><span class="p">,</span> <span class="n">dataSizeBit</span><span class="p">)</span>
	<span class="n">lengthSizeBit</span> <span class="o">:=</span> <span class="kt">int</span><span class="p">(</span><span class="n">lengthSizeBit64</span><span class="p">)</span>
	<span class="n">megaString</span> <span class="o">=</span> <span class="n">megaString</span><span class="p">[</span><span class="n">dataSizeBit</span><span class="o">:</span><span class="p">]</span>

	<span class="n">msgDecoded</span> <span class="o">:=</span> <span class="s">""</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="kt">uint64</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">offset</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">ParseUint</span><span class="p">(</span><span class="n">megaString</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="n">dataSizeBit</span><span class="p">],</span> <span class="m">2</span><span class="p">,</span> <span class="n">dataSizeBit</span><span class="p">)</span> <span class="c">// offset N</span>
		<span class="n">megaString</span> <span class="o">=</span> <span class="n">megaString</span><span class="p">[</span><span class="n">dataSizeBit</span><span class="o">:</span><span class="p">]</span>
		<span class="n">length</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">ParseUint</span><span class="p">(</span><span class="n">megaString</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="n">lengthSizeBit</span><span class="p">],</span> <span class="m">2</span><span class="p">,</span> <span class="n">lengthSizeBit</span><span class="p">)</span> <span class="c">// longueur N</span>
		<span class="n">megaString</span> <span class="o">=</span> <span class="n">megaString</span><span class="p">[</span><span class="n">lengthSizeBit</span><span class="o">:</span><span class="p">]</span>
		<span class="n">msgDecoded</span> <span class="o">+=</span> <span class="n">megaStringToSearch</span><span class="p">[</span><span class="n">offset</span> <span class="o">:</span> <span class="n">offset</span><span class="o">+</span><span class="n">length</span><span class="p">]</span> <span class="c">// notre message décodé mais sous forme binaire</span>
	<span class="p">}</span>

	<span class="c">// transformation du binaire =&gt; ASCII</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">msgDecoded</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="m">8</span> <span class="p">{</span>
		<span class="n">val</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">ParseUint</span><span class="p">(</span><span class="n">msgDecoded</span><span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">i</span><span class="o">+</span><span class="m">8</span><span class="p">],</span> <span class="m">2</span><span class="p">,</span> <span class="m">8</span><span class="p">)</span>
		<span class="n">flag</span> <span class="o">+=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">flag</span>
<span class="p">}</span>
</code></pre></div></div> <p>Verdict :</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go run decoder.go _message.extracted/204200 
le message secret: DGSEESIEE<span class="o">{</span>FL<span class="k">****</span>R3<span class="o">}</span>
</code></pre></div></div> <p><strong>FIN BRUTALE</strong></p> <ul> <li><a href="/assets/files/le_code.dart">le_code.dart</a></li> <li><a href="/assets/files/decoder.go">decoder.go</a></li> <li><a href="https://mega.nz/file/boQyCRZb#y6V-0ec5OSaMkJJHwkksvi1Hpa6nUEh-QbqS4Yo-j3Y">message</a></li> </ul> </div> </article> </main> <footer class="footer"> <span class="footer_item">TonyBounty &copy; last update 11/2020</span> <br><a href="https://neovim.io/" target="_blank"><img src="/assets/img/neovim.png"></a> <small class="footer_copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> </div> </body> </html>
